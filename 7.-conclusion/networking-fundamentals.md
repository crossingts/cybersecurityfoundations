---
description: >-
  This chapter covered networking fundamentals by way of tracing the movement of
  a data packet from one host to another across the Internet - highlighting key
  network devices and protocols involved
---

# Networking fundamentals

## Chapter 4: Networking fundamentals <a href="#chapter-4-networking-fundamentals" id="chapter-4-networking-fundamentals"></a>

Chapter 4 covered two main objectives. First, this chapter covered networking fundamentals by way of tracing the movement of a data packet from one host to another across the Internet - highlighting key network devices and network protocols involved, and data encapsulation/de-encapsulation against the OSI model layers. Second, this chapter established the practical groundwork for building and securing a network by teaching essential configuration skills, including static routes and ACLs. Finally, you learned to integrate critical services like DHCP, DNS, and NAT to provide a complete and functional network environment.

**The first section, Network Devices and Their Functions**, established the fundamental building blocks of computer networking. At its core, a network is a system for transporting data between hosts—any device, such as a client or server, identified by a unique IP address. These hosts are logically grouped into networks and subnets, which require specialized hardware to manage communication. The discussion traced the evolution of key network devices, from simple signal boosters like repeaters and broadcast-heavy hubs, to more intelligent bridges that filter traffic. Modern internal communication is primarily handled by switches, which efficiently direct data within a network by learning device addresses. Connectivity between different networks is the domain of routers, which use routing tables to intelligently forward traffic across the internet.

The arrangement of these devices creates a functional hierarchy: end hosts connect to switches, which aggregate local traffic and connect to routers that serve as gateways to other networks. Firewalls, whether network-based or host-based, provide critical security by monitoring and controlling this traffic according to defined rules. Together, these components form the essential infrastructure that enables all digital communication, from a simple local file transfer to global internet access. Understanding the distinct roles of switches (for intra-network switching) and routers (for inter-network routing) is key to grasping how data moves seamlessly across complex, interconnected systems.

**The Open Systems Interconnection (OSI) Model section** provided a standardized, seven-layer framework to understand how data flows across a network, with each layer performing a distinct function. The foundational lower layers handle the physical and logical movement of data: the Physical Layer (L1) deals with raw bit transmission over cables or wireless signals; the Data Link Layer (L2) manages hop-to-hop delivery using MAC addresses and devices like switches; the Network Layer (L3) handles end-to-end delivery across networks using IP addresses and routers; and the Transport Layer (L4) ensures service-to-service delivery through protocols like TCP and UDP, utilizing port numbers to direct traffic to the correct application.

The upper layers focus on application-level interactions: the Session, Presentation, and Application Layers (L5-L7) manage dialogue control, data translation, and user interface functions, though in modern practice they are often grouped as a single "Application" layer. The entire communication process relies on encapsulation, where each layer adds its own header (e.g., MAC, IP, TCP) as data travels down the stack on the sending side, and de-encapsulation, where these headers are stripped away as data moves up the stack on the receiving side. This layered abstraction is crucial for troubleshooting, developing networked applications, and understanding the roles of specific protocols and devices within a network.

**The Host to Host Communication in Networking section** detailed how hosts communicate, hinging on a host's ability to determine whether the destination is on its local network or a foreign one. Using its own IP address and subnet mask, a host determines the network ID of the destination. If the IDs match, the target is local, and the source host uses the Address Resolution Protocol (ARP) to broadcast a request and discover the destination's MAC address. Once resolved, this mapping is cached, and the host can construct the necessary Layer 2 (MAC) and Layer 3 (IP) headers to send the data directly.

If the network IDs differ, the destination is on a foreign network. In this case, the host's traffic must be sent to its configured default gateway. The host again uses ARP, but this time to resolve the router's MAC address corresponding to its gateway IP. The constructed packet has a Layer 3 header with the ultimate destination's IP but a Layer 2 header addressed to the router's MAC. The router receives the frame, strips the Layer 2 header, and forwards the packet toward its final destination. Crucially, the ARP entry for the default gateway is reused for all communications to foreign networks, making the router the consistent first hop for external traffic.

**The section on Network Protocols and Their Functions** explained that network protocols are the standardized rules and message formats that enable devices to communicate across networks, forming the operational language of the internet. These protocols are organized within layered models like TCP/IP, which maps to the OSI model, with each protocol performing a specific function. For a host to achieve internet connectivity, it must be configured with four key parameters: an IP address, a subnet mask, a default gateway, and a DNS server. The Dynamic Host Configuration Protocol (DHCP) automates this process by dynamically assigning these parameters to hosts upon connecting to a network.

Several core protocols facilitate different aspects of communication. The Domain Name System (DNS) acts as the internet's phonebook, translating human-readable domain names into machine-readable IP addresses. At the local network level, the Address Resolution Protocol (ARP) maps IP addresses to physical MAC addresses. Application-layer protocols then govern specific services: FTP transfers files, SMTP sends email, and HTTP fetches web pages. Security is added by SSL/TLS, which encrypts data in transit, creating the secure HTTPS protocol for web browsing. Together, these interdependent protocols form the essential framework that allows data to flow reliably and securely across the global internet.

**The next section, Typing `www.google.com` into a Web Browser**, synthesized core networking concepts by tracing the intricate journey of a packet when `www.google.com` is entered into a web browser. The process begins with the host using DNS to resolve the domain name to an IP address. To send the DNS query, the host consults its routing table, determines the destination is on a foreign network, and uses ARP to discover the MAC address of its default gateway. The packet then travels hop-by-hop across the internet, with each router using its own routing table to forward it until it reaches the DNS server. The reply follows the same path in reverse, ultimately delivering the Google server's IP address to the originating host.

With the IP address known, the host initiates an HTTP/HTTPS request. It again uses its routing and ARP tables to send the packet to its gateway. Routers across the internet forward the packet based on their routing tables until it reaches the Google web server. The server's response retraces the path back to the host. Throughout this entire cycle, switches use their MAC address tables for local forwarding, while routers rely on routing tables for inter-network path selection and ARP tables to map the next-hop IP address to a MAC address at each segment. This end-to-end flow demonstrates the harmonious interaction of the three critical tables—MAC, ARP, and routing—that enable data to navigate complex networks.

**The section Cisco IOS CLI and Basic Device Security** transitioned from theoretical networking concepts to the practical skills of configuring and securing network hardware using the Cisco IOS Command-Line Interface (CLI). The CLI is the primary text-based environment for managing Cisco devices, accessed initially via a console port connection using a terminal emulator like PuTTY. Users navigate hierarchical command modes: User EXEC mode for basic viewing, Privileged EXEC mode for full access, and Global Configuration mode for making changes. A core administrative task is implementing basic device security, starting with controlling access to privileged mode using passwords.

The section emphasized the critical difference between the less secure `enable password` command, which stores passwords in plain text, and the recommended `enable secret` command, which uses strong encryption (MD5) by default. The weaker `service password-encryption` command can encrypt other plaintext passwords in the configuration. Administrators must understand the distinction between the active running-config (in RAM) and the saved startup-config (in NVRAM), using commands like `copy running-config startup-config` to make changes permanent. This foundation of CLI navigation and basic security is essential for any subsequent network device management and protection.

**The section on Connected and Local Routes** established the foundational mechanics of IP routing, the process by which routers determine the best path to forward packets toward their destination. A router's decisions are guided by its routing table, a set of instructions for reaching known networks. When an IP address is configured and activated on a router interface, the router automatically populates this table with two critical route types: a Connected route (denoted by C), which defines the entire network attached to that interface, and a Local route (denoted by L), which points to the router's own specific interface IP address. These initial entries form the essential, direct knowledge a router has about its immediate network environment.

A router's core logic is selecting the best path when forwarding a packet. If no route matches the packet's destination IP address, the packet is dropped. However, if multiple routes match—such as both a connected route for a network and a local route for a specific host within it—the router employs the "longest prefix match" rule. It chooses the most specific route, the one with the longest subnet mask (e.g., /32 is more specific than /24). This ensures precise delivery, guaranteeing that traffic destined for the router itself is processed internally, while traffic for other hosts in a connected network is correctly forwarded out the appropriate interface.

**The section How to Configure Static Routes on Cisco Routers** detailed the manual configuration of static routes to enable communication with networks not directly connected to a router. The process begins with end-hosts, which must be configured with a default gateway—the IP address of their local router's interface—to send traffic off their local subnet. A router's automatically generated connected (C) and local (L) routes only provide paths to its own interface (Local route) and a directly attached network (Connected route). However, for the router to be able to send traffic to destinations not directly connected to the router itself, it must be explicitly told where to send packets using a manually configured static route. Configuration is performed from global configuration mode using the `ip route` command, specifying the destination network, subnet mask, and either the IP address of the next-hop router or the local exit interface.

A critical prerequisite is planning for two-way reachability; for hosts on different networks to communicate, every router in the path requires a route to both the source and destination networks. Static routes can be configured using three syntaxes: specifying only the next-hop IP address, only the exit interface (which relies on proxy ARP), or both. A special case is the default static route (`ip route 0.0.0.0 0.0.0.0 <next-hop>`), which acts as a catch-all gateway of last resort for any traffic not matching a more specific route. Successful implementation is verified using `ping`, which confirms two-way reachability, and understanding that while a packet's Layer 3 IP addresses remain constant, its Layer 2 MAC addresses are rewritten at each router hop.

**The Comparing TCP to UDP section** provided a detailed technical comparison of the Transport layer protocols TCP and UDP, focusing on their mechanisms and design philosophies. TCP is a connection-oriented, stateful protocol that guarantees reliable data delivery through a defined process. Before data exchange, it performs a three-way handshake (SYN, SYN-ACK, ACK) to establish a session and uses a four-way handshake (FIN, ACK) for termination. Reliability is achieved through sequence and acknowledgment numbers, which enable in-order delivery and trigger retransmission timers for any unacknowledged segments. Furthermore, TCP implements flow control using a window size field, allowing the receiver to dynamically manage the sender's data rate to prevent overwhelming its buffer.

In contrast, UDP is a connectionless, stateless protocol designed for minimal overhead. Its header is only 8 bytes long, containing only source/destination ports, length, and a checksum, omitting the sequence, acknowledgment, and control fields found in TCP's 20-byte header. Consequently, UDP offers no handshakes, no delivery guarantees, no retransmissions, no sequencing, and no flow control; it is a simple "fire-and-forget" datagram service. The choice between protocols is application-dependent: TCP is essential for reliable transfers like web browsing (HTTP/HTTPS) or file downloads (FTP), while UDP's low latency and overhead make it suitable for real-time applications like VoIP, video streaming, and DNS queries. Both protocols utilize port numbers for session multiplexing, enabling multiple applications to communicate simultaneously on a single host.

**The section titled How to Configure Standard ACLs on Cisco Routers** explained the configuration of standard Access Control Lists (ACLs) on Cisco IOS, which function as packet filters based solely on source IP addresses. ACLs consist of an ordered sequence of Access Control Entries (ACEs) that are processed from the top down; the router stops evaluating once a packet matches an entry and takes the corresponding permit or deny action. A critical concept is the implicit `deny any` statement automatically appended to the end of every ACL, which discards all traffic not explicitly permitted by preceding entries. For an ACL to take effect, it must be applied to a router interface in either the inbound or outbound direction using the `ip access-group` command, with a best practice of placing standard ACLs as close as possible to the destination network.

Standard ACLs come in two forms: numbered and named. Numbered ACLs (using identifiers 1-99 or 1300-1999) are configured in global configuration mode with commands like `access-list 10 permit 192.168.1.0 0.0.0.255`. Named ACLs offer more descriptive management and are configured by first entering standard named ACL configuration mode with `ip access-list standard <NAME>`, then defining entries. In both types, the order of entries is paramount, as a broader `deny` statement placed before a specific `permit` can inadvertently block intended traffic. Configuration is verified using commands such as `show access-lists`, which displays entries and packet hit counts, and `show running-config`.

**The Role of DNS Within the Network section** detailed the Domain Name System (DNS), which is the hierarchical, distributed protocol that translates human-readable domain names (e.g., [youtube.com](https://youtube.com/)) into machine-readable IP addresses. DNS queries typically use UDP port 53 and involve specific record types: 'A' records for IPv4 addresses and 'AAAA' (quad-A) records for IPv6 addresses. Client devices, configured with DNS server addresses via DHCP or statically, send resolution requests to these servers. The process can be examined using client commands like `nslookup` and `ipconfig /displaydns`, the latter showing a local cache that stores responses to improve efficiency. As a legacy alternative, a local `hosts` file can provide static name-to-address mappings, though this is not scalable.

A Cisco router can be configured to operate in two DNS roles: as a client and as a basic server. As a DNS client, the router is configured with the `ip name-server` command to specify upstream DNS resolvers, enabling the router itself to resolve names when using commands like `ping` or `traceroute`. As a DNS server, the router is enabled with `ip dns server` and populated with static entries using the `ip host` command, allowing it to answer queries from other network devices. Crucially, it can be configured to forward unresolved queries to an external server (e.g., 8.8.8.8), acting as a recursive resolver for the local network. The router's name table, viewed with `show hosts`, displays both manually configured permanent entries and temporary entries dynamically learned through its own client queries.

**This section Configuring and Verifying DHCP Client and Relay** studied the Dynamic Host Configuration Protocol (DHCP), which automates the assignment of IP parameters to network clients. The core mechanism is the four-message DORA process: a client broadcasts a DHCP Discover message (UDP port 68 to 67) from 0.0.0.0; a server responds with a unicast or broadcast Offer containing a proposed IP address, lease time, default gateway, and DNS server; the client broadcasts a Request to formally accept one offer; and the server sends a final Acknowledgment. Client-side verification and management on Windows use `ipconfig /all` to view leased parameters, `ipconfig /release` to terminate a lease (sending a unicast DHCP Release), and `ipconfig /renew` to initiate a new DORA exchange.

Configuration on Cisco IOS involves three roles. To configure a router as a DHCP server, a pool is created (`ip dhcp pool <name>`) where the network range, default router (`default-router`), DNS server (`dns-server`), domain name, and lease time are defined; specific addresses can be excluded (`ip dhcp excluded-address`). To centralize service across subnets, a router is configured as a DHCP relay agent using the `ip helper-address <server-ip>` command on the client-facing interface, which forwards client broadcasts as unicasts to the remote server. Finally, a router interface itself can be a DHCP client by using the `ip address dhcp` command in interface configuration mode, causing it to request an address via the DORA process. Server operation is verified with `show ip dhcp binding`, which displays active leases.

**The next section covered Static NAT Configuration**. Static NAT (Network Address Translation) is a method for enabling hosts with private RFC 1918 addresses (e.g., 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to communicate over the public Internet. Static NAT creates a permanent, one-to-one mapping between an inside local address (the host's actual private IP) and an inside global address (a public IP representing that host to the outside world). This bidirectional mapping not only allows the internal host to initiate outbound connections but also enables external hosts to reach it by targeting its inside global address, making static NAT suitable for hosting internal servers.

Configuration on a Cisco IOS router involves three key steps. First, interfaces are designated with `ip nat inside` (for the internal network) and `ip nat outside` (for the external network). Second, the static mapping is defined globally using the command `ip nat inside source static <inside-local> <inside-global>`. The translation table, viewed with `show ip nat translations`, will permanently list this mapping, while dynamic session entries (showing protocol and port details) appear as traffic flows and can be cleared with `clear ip nat translation *`. Verification is completed using `show ip nat statistics`, which confirms active translation counts and the interfaces involved.

**The final section, OSI Model Layers and Security Threats**, systematically mapped common security threats to their corresponding OSI model layers, illustrating how attacks target specific vulnerabilities inherent to each layer's function. At the lower layers (1-4), threats primarily aim to disrupt infrastructure or intercept data through force or deception. Examples include cable tapping and sniffing (L1), ARP spoofing and MAC flooding (L2), ICMP floods and IP spoofing (L3), and TCP/UDP floods (L4). As we move up the stack, attacks become more focused on manipulating logic and exploiting trust: session hijacking and SSL stripping target session management (L5), phishing and malicious uploads exploit presentation formats and human behavior (L6), while SQL injection and DNS spoofing directly attack application logic and services (L7).

Correspondingly, effective mitigation strategies are tailored to the characteristics of each layer. Defenses for the lower, infrastructure-focused layers rely heavily on technical controls like encryption (WPA3, MACsec), network hardening (BCP38 filtering, port security, Dynamic ARP Inspection), and rate limiting. For the upper layers, where human interaction and application logic are key, defenses shift to include robust input validation, web application firewalls (WAFs), secure development practices, and crucial human-centric measures like user education, email filtering (DMARC/DKIM/SPF), and multi-factor authentication (MFA). This layered defense-in-depth approach is essential, as a vulnerability at any level can compromise the entire system's security.